<!doctype html public "-//w3c//dtd html 4.0 Transitional//en">
<html>
<head>
  <title>dbExpress driver for PostgreSQL</title>
<meta http-equiv="Content-Type" content="text/html">
<style>
body {
  overflow: hidden; 
  margin: 0px 0px 0px 0px;
  padding: 0px 0px 0px 0px;
  background: #ffffff; 
  color: #000000;
  font-family: Verdana, Arial, Helvetica, sans-serif;
  font-size: 70%;
  width: 100%;
  }
p
    {
    margin: .5em 0em .5em 0em;
    }
ol, ul
    {
    margin-top: .5em; 
    }
li
    {
    margin-bottom: .5em;
    }
ul p, ol p, dl p
    {
    margin-left: 0em;
    }
blockquote.dxOverload
    {
    margin: .5em 1.5em .5em 1.5em;
    }
h1, h2, h3, h4
    {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    margin-bottom: .4em; 
    margin-top: 1em;
    font-weight: bold;
    }
h1
    {
    font-size: 120%;
    margin-top: 0em;
    }
h2
    {
    font-size: 130%;
    }
h3
    {
    font-size: 115%;
    }
h4
    {
    font-size: 100%;
    }
.dxH1, .dxH2, .dxH3, .dxH4
    {
    margin-left: -18px;    
    }
A
  {
  color: #0000FF;
  }
A:link
  {
  color: #0000FF;
  }
A:active
  {
  color: #000080;
  }
A:visited
  {
  color: #800080;
  }
A:hover
  {
  color: #FF0000;
  }
pre
  {
  font-family: Courier New;
  font-size: 9pt;
  color: #000060;
  margin-top: 0px;
  }
code, p.example, p.sourcecode, table.sourcecode, tr.sourcecode, td.sourcecode
  {
  font-family: Courier New;
  font-size: 9pt;
  color: #000060;
  }
div#pagetop {
  margin: 0px;
  padding: 0px;
  background-color: #99ccff;   
  height: 44;
  width: 100%;
  border-bottom: 1px solid #999999;
  }
div#pagebody {
  margin: 0px 0px 0px 0px;
  padding: 5px 10px 0px 22px;
  height: 90%;
  width: 100%;
  overflow: auto;
  background-color: #FFFFFF;
  vertical-align: top;
  }
table#BannerTable
  {
  width: 100%;
  height: 100%;
  border-collapse:collapse;
  font-family: Verdana, Arial, Helvetica, sans-serif;
  }
table#BannerTable td
  {
  padding-left: 8px;
  padding-right: 8px;
  }
tr#BannerTopRow
  {
  font-style: italic;
  font-size: 70%;
  }
tr#BannerTopRow td
  {
  padding-top: 4px;
  }
tr#Banner2ndRow
  {
  font-weight: bold;
  font-size: 80%;
  }
tr#Banner2ndRow td
  {
  padding-bottom: 4px;
  }
td#BannerCol
  {
  font-style: italic;
  font-size: 70%;
  padding-bottom: 4px;
  }
td#Banner2ndCol
  {
  font-weight: bold;
  font-size: 80%;
  padding-bottom: 4px;
  }
table.filtereditemlisttable, table.xmldoctable
    {
    width: 95%; 
    margin-top: .6em;
    margin-bottom: .3em;
    border-width: 1px 1px 0px 0px;
    border-style: solid;
    border-color: #999999;
    background-color: #999999; 
    font-size: 100%;
  border-collapse:collapse;
    }
table.filtereditemlisttable th, table.filtereditemlisttable td, table.xmldoctable th, table.xmldoctable td
    { 
    border-width: 0px 0px 1px 1px;
    border-style: solid;
    border-color: #999999;
    padding: 4px 6px;
    text-align: left;
    vertical-align: top;
    }
table.filtereditemlisttable th, table.xmldoctable th
    { 
    background: #cccccc; 
    vertical-align: bottom;
    }
table.filtereditemlisttable td, table.xmldoctable td
    {
    background-color: #ffffff;
    vertical-align: top;
    }

table.desctable {
    width: 95%;
    margin-top: .6em;
    margin-bottom: .3em;
    border-width: 1px 1px 0px 0px;
    border-style: solid;
    border-color: #999999;
    background-color: #999999;
    font-size: 100%;
}
table.desctable th, table.desctable td {
    border-style: solid;
    border-width: 0px 0px 1px 1px;
    border-style: solid;
    border-color: #999999;
    padding: 4px 6px;
    text-align: left;
    vertical-align: top;
}
table.desctable th {
    background: #cccccc;
    vertical-align: bottom;
}
table.desctable td {
    background: #ffffff;
    vertical-align: top;
    }

</style>

<script>

var Engine;
var enOpera = 'Opera';
var enIE = 'IE';
var enGecko = 'Gecko';

function TestEngine()
{
  if (document.all) {
    if (window.opera) {
      Engine = enOpera;
    }
    else {
      Engine = enIE;
    }
  }
  else {
    Engine = enGecko;
  }
}


function AdjustContentSize()
{
  var cDiv = document.getElementById("pagebody");
  if ((Engine == enGecko)||(Engine == enOpera))//amend padding
    {
      var w = document.body.clientWidth;
      cDiv.style.width = w - 32;
    }
  var h = document.body.clientHeight;
  var diff = 44;
  if ((Engine == enGecko)||(Engine == enOpera)) diff = diff + 6;
  cDiv.style.height = h - diff;
}


function Startup()
{
  //add startup code here
}
</script>

</head>


<body onresize="AdjustContentSize()" onload="Startup()">

<div id="pagetop">
  <table id="BannerTable">
    <tr id="BannerTopRow">
      <td>dbExpress driver for PostgreSQL</td>
      <td align="right"><i><a href="History.html">History</a></i></td>
    </tr>
    <tr>
      <td id="Banner2ndCol">Readme</td>
      <td id="BannerCol" align="right"><i><a href="Support.html">Support</a></i></td>
    </tr>
  </table>
</div>

<div id="pagebody">

<!-- begin content -->

<p>
dbExpress is database-independent layer that defines common
interface to provide fast access to SQL database servers. For
each supported server dbExpress provides a driver as an
independent library that implements common dbExpress interfaces
for processing queries and stored procedures. As data-access layer
is thin and simple, dbExpress provides high performance database
connectivity and is easy to deploy. dbExpress drivers are available
for Windows as dynamic-link libraries. 
</p>

<p>
dbExpress for PostgreSQL driver provides access to PostgreSQL database 
server and is based on Borland dbExpress data access technology. 
<!-- It uses directly PostgreSQL client software to connect to server. --> 
</p>

  <br>

<ul>
  <li><a href="#key_features">Key features</a></li>
  <li><a href="#compatibility">Compatibility</a></li>
  <li><a href="#windows_installation_notes">Windows installation notes</a></li>
<!--   <li><a href="#linux_installation_notes">Linux installation notes</a></li>
 -->  <li><a href="#using">Using</a></li>
  <li><a href="#64bit">64-bit Application Development</a></li>
  <li><a href="#type_map">Type map</a></li>
  <li><a href="#extended_driver_options">Extended driver options</a></li>
  <li><a href="#tcrsqlconnection">TCRSQLConnection</a></li>
  <li><a href="#dbmon">Using DBMonitor</a></li>
  <li><a href="#deployment">Deployment</a></li>
  <li><a href="#trial_limitations">Trial limitations</a></li>
  <li><a href="#notes">Notes</a></li>
  <li><a href="#known_problems">Known problems</a></li>
  <li><a href="#demo_projects">Demo projects</a></li>
</ul>

<h4><a name="key_features"></a>Key features</h4>

<p>
The following list describes the main features of the dbExpress for PostgreSQL driver:
</p>

<ul>
  <li>Full support of the latest versions of PostgreSQL database server</li>
  <li>High performance</li>
  <li>Ability of monitoring query execution with <a href="#dbmon">DBMonitor</a> </li>
  <li><a href="#extended_driver_options">Extended options</a> for advanced behaviour</li>
  <li>Complete support for dbExpress version 4</li>
  <li>Available source code</li>
  <li>Included annual <a href="Support.html">Subscription with Priority Support</a></li>
  <li>Licensed royalty-free per developer, per team, or per site</li>
</ul>

<h4><a name="compatibility"></a>Compatibility</h4>

<p>
The driver works with RAD Studio XE8, RAD Studio XE7, RAD Studio XE6, RAD Studio XE5, RAD Studio XE4, RAD Studio XE3, RAD Studio XE2, RAD Studio XE, RAD Studio 2010, RAD Studio 2009, RAD Studio 2007, Turbo Delphi, Turbo Delphi for .NET, Turbo C++, Delphi 2006, Delphi 2005, Delphi 7, Delphi 6, and C++Builder 6.
</p>

<p>
It supports PostgreSQL server versions since 7.1 up to 9.4 and does not require PostgreSQL client to be installed on the client side. 
</p>

<u>You should also pay attention to the following notes:</u> 
<ol>
  <li>
    It is strongly recommended to use the corresponding library with your IDE. Please take a look at <a href="#lib_names">this table</a> for more details.
  </li>
  <li>
    Update Pack 2 is required for Delphi 2006 .NET Personality.
  </li>
  <li>
    Update Pack 3 is required for C++Builder 2007 and Delphi 2007 for Win32.
  </li>
</ol>

<h4><a name="windows_installation_notes"></a>Windows installation notes</h4>
<u>RAD Studio 2007 and higher</u>
<p>
The standard TSQLConnection component in RAD Studio 2007 and higher provides exactly the same functionality like TCRSQLConnection does. Therefore TCRSQLConnection component is not registered automatically. But source code of the package containing this component is installed for providing backward compatibility. If you need to use TCRSQLConnection, you should compile and install its packages manually. They are located in the &lt;Driver_Installation_Directory&gt;\Source\DelphiXX\ directory. The <i>dclcrdbxXXX.dproj</i> package is used with Delphi for Win32 and C++Builder. And the <i>Devart.Dbx.dproj</i> package is used with Delphi for .Net.
</p>

<p>
If you have only C++Builder installed, you can compile the package from the command line using a command like the following one:
<pre>C:\Program Files\CodeGear\RAD Studio\5.0\bin\dcc32.exe" dclcrdbx105.dpk</pre>
 
To compile an application that uses TCRSQLConnection components, it is necessary to add the path to TCRSQLConnection sources to the Search path in Project Options or to the Library path in Environment Options:
<ul>
  <li>in Delphi for Win32 add &lt;Driver_Installation_Directory&gt;\Source;</li>
  <li>in Delphi for .Net add &lt;Driver_Installation_Directory&gt;\Source and &lt;Driver_Installation_Directory&gt;\Source\Net;</li>
  <li>in C++Builder add &lt;Driver_Installation_Directory&gt;\Source to the Library path and to the Include path in Project Options.</li>
</ul>
</p>

<u>Delphi 2006</u>
<p>
If you use TCRSQLConnection in applications developed with C++Builder Personality of Delphi 2006 
or Turbo C++, you should add the path to the driver folder to Project Options|Library and Project Options|Include.
</p>

<!-- <h4><a name="linux_installation_notes"></a>Linux installation notes</h4>
<p>
Make libsqlpg.so.X.X library available for applications by correcting
LD_LIBRARY_PATH environment variable or by copying it to directory already
contained in LD_LIBRARY_PATH.
</p>

<p>
To work with driver from IDE, you need to register driver in dbExpress
configuration files.
</p>

<ol>
  <li>Find dbxdrivers file (path is similar to /home/&lt;user&gt;/.borland)</li>
  <li>Add or replace the following sections:
  <pre>
  [DevartPostgreSQL]
  GetDriverFunc=getSQLDriverPostgreSQL
  LibraryName=libsqlpg.so.X.X
  VendorLib=libgds.so.0
  BlobSize=-1
  DataBase=
  User_Name=
  Password=

  </pre>
  </li>

  <li>In section [Installed Drivers] add line
  <pre>
  DevartPostgreSQL=1
  </pre>
  </li>

  <li>Find the dbxconnections file (path is similar to /home/&lt;user&gt;/.borland)</li>
  <li>Add or replace the following lines:
  <pre>
  [Devart PostgreSQL]
  BlobSize=-1
  DataBase=
  DriverName=DevartPostgreSQL
  User_Name=
  Password=
  </pre>
  </li>
</ol> -->

<h4><a name="using"></a>Using</h4>

<p>
The use of dbExpress for PostgreSQL is the very same as one of standard dbExpress
drivers supplied by Borland. For additional information refer to 
help on TSQLConnection component.
</p>

<p>
To setup SQLConnection for using the Devart driver, just set at design-time
ConnectionName property to "Devart PostgreSQL" connection 
configurations.
</p>

<p>
Set connection parameters such as User_Name, Password, HostName and Database
to provide login information.
</p>

<p>
Borland Turbo products and Delphi 2006 introduce dbExpress 3.0 interfaces,
CodeGear RAD Studio 2007 and higher introduce dbExpress 4.0. They are implemented
in dbexppgsql30.dll and dbexppgsql40.dll correspondingly, and we highly recommend
using the correspondent driver.
</p>

<h4><a name="64bit"></a>64-bit Application Development</h4>

<p>
RAD Studio XE2 and higher IDE is a 32-bit application. It means that it cannot load 64-bit 
packages at design-time. So, all design-time packages in RAD Studio XE2 and higher IDE are
32-bit.
</p>

<p>
Therefore, if you develop your own components, you should remember that for the purpose 
of developing components with the 64-bit platform support, you have to compile run-time 
packages both for the 32- and 64-bit platforms, while design-time packages need to be 
compiled only for the 32-bit platform. This might be a source of difficulties if your 
package is simultaneously both a run-time and a design-time package, as it is more than 
likely that this package won't be compiled for the 64-bit platform. In this case, you 
will have to separate your package into two packages, one of which will be used as 
run-time only, and the other as design-time only.
</p>

<p>
For the same reason, if your design-time packages require that certain DLLs be loaded, 
you should remember that design-time packages can be only 32-bit and that is why they 
can load only 32-bit versions of these DLLs, while at run-time 64-bit versions of the 
DLLs will be loaded. Correspondingly, if there are only 64-bit versions of the DLL on 
your computer, you won't be able to use all functions at design-time and, vice versa, 
if you have only 32-bit versions of the DLLs, your application won't be able to work 
at run-time.
</p>

<p>
Since dxExpress driver for PostgreSQL does not require that the PostgreSQL client be 
installed to work with the database, the development of applications for the 
x64 platform does not differ from the development of application for Windows x86.
</p>

<h4><a name="example"></a>Example</h4>

<p>
Connection with :
</p>

<pre>
  SQLConnection.LibraryName := &lt;library name&gt;; // &lt;library name&gt; depends on your IDE version. See the <a href="#lib_names">table below</a>.
  SQLConnection.VendorLib := 'not used';
  SQLConnection.GetDriverFunc := 'getSQLDriverPostgreSQL';
  SQLConnection.Params.Clear;
  SQLConnection.Params.Add('User_Name=MyName');
  SQLConnection.Params.Add('Password=MyPassword');
  SQLConnection.Params.Add('HostName=MyServer');
  SQLConnection.Params.Add('Database=MyDatabase');
  SQLConnection.Open;
</pre>

<a name="lib_names"> </a>
<p>
The following table determines how library name depends on the used IDE version:
</p>
<table class="desctable" cellspacing="0" style="width: 500">
<tr>
  <th width="30%">Library name</th>
  <th width="70%">IDE version</th>
</tr>

<tr>
  <td>dbexppgsql<b>40</b>.dll</td>
  <td>CodeGear RAD Studio 2007 and higher</td>
</tr>

<tr>
  <td>dbexppgsql<b>30</b>.dll</td>
  <td>Delphi 2006 and Turbo products</td>
</tr>

<tr>
  <td>dbexppgsql.dll</td>
  <td>other IDE versions</td>
</tr>

</table>

<h4><a name="type_map"></a>Type map</h4>

<p>
PostgreSQL data types are mapped to TFieldType in the following way (by default, if EnableBCD property is True):
</p>

<table class="desctable" cellspacing="0">

<tr>
<th width="40%">PostgreSQL type</th>
<th width="30%">Field type</th>
<th width="30%">Field class</th>
</tr>

<tr>
<td>SMALLINT</td>
<td>ftSmallint</td>
<td>TSmallintField</td>
</tr>

<tr>
<td>INTEGER</td>
<td>ftInteger</td>
<td>TIntegerField</td>
</tr>

<tr>
<td>BIGINT</td>
<td>ftFMTBcd</td>
<td>TFMTBCDField</td>
</tr>

<tr>
<td>NUMERIC</td>
<td>ftFMTBcd</td>
<td>TFMTBCDField</td>
</tr>

<tr>
<td>REAL</td>
<td>ftFloat</td>
<td>TFloatField</td>
</tr>

<tr>
<td>DOUBLE PRECISION</td>
<td>ftFloat</td>
<td>TFloatField</td>
</tr>

<tr>
<td>MONEY</td>
<td>ftCurrency</td>
<td>TCurrencyField</td>
</tr>

<tr>
<td>BOOLEAN</td>
<td>ftBoolean</td>
<td>TBooleanField</td>
</tr>

<tr>
<td>OID</td>
<td>ftInteger</td>
<td>TIntegerField</td>
</tr>

<tr>
<td>CHAR</td>
<td>ftString</td>
<td>TStringField</td>
</tr>

<tr>
<td>VARCHAR</td>
<td>ftString</td>
<td>TStringField</td>
</tr>

<tr>
<td>NAME</td>
<td>ftString</td>
<td>TStringField</td>
</tr>

<tr>
<td>TEXT</td>
<td>ftMemo</td>
<td>TMemoField</td>
</tr>

<tr>
<td>BYTEA</td>
<td>ftBlob</td>
<td>TBlobField</td>
</tr>

<tr>
<td>DATE</td>
<td>ftDate</td>
<td>TDateField</td>
</tr>

<tr>
<td>TIME</td>
<td>ftTime</td>
<td>TTimeField</td>
</tr>

<tr>
<td>TIMESTAMP</td>
<td>ftTimeStamp</td>
<td>TSQLTimeStampField</td>
</tr>
</table>

<p>
When EnableBCD option is False dataset maps BIGINT and NUMERIC fields as following:
</p>

<table class="desctable" cellspacing="0">

<tr>
<th width="40%">PostgreSQL type</th>
<th width="30%">Field type</th>
<th width="30%">Field class</th>
</tr>

<tr>
<td>BIGINT</td>
<td>ftFloat</td>
<td>TFloatField</td>
</tr>

<tr>
<td>NUMERIC</td>
<td>ftFloat</td>
<td>TFloatField</td>
</tr>

</table>


<h4><a name="extended_driver_options"></a>Extended driver options</h4>

<p>
The dbExpress driver for PostgreSQL provides several extended options that expand functionality of the driver.
In order to overcome restrictions of dbExpress on several IDEs, the driver installation includes the 
TCRSQLConnection component. It simplifies working with extended driver options.
</p>

<p>
The dbExpress technology version 4 in CodeGear RAD Studio 2007 and higher does
not have such restrictions, so the TCRSQLConnection component has no sense for
these IDEs.
</p>

<p>
Starting with CodeGear RAD Studio 2007 you should assign parameter values to 
TSQLConnection and TCRSQLConnection at run time in this way:
<pre>SQLConnection.Params.Values['Option Name'] := 'Option Value';</pre>
</p>

<p>
In other IDE versions it is better to use TCRSQLConnection instead of standard 
TSQLConnection. Extended options are available with TSQLConnection only at run time. 
</p>

<p>
To setup these options at design time, you should use the Params property
of TCRSQLConnection.
</p>

<p>
To use an option with TSQLConnection in Delphi 2006 and lower IDE versions, you should define constants and set
appropriate option values using event handlers like:
<pre>
TSQLConnection.AfterConnect
TSQLQuery.BeforeOpen
</pre>
</p>

<p>
Below is the example that demonstrates setting extended driver options in Delphi 2006 and lower IDE versions:
</p>

<pre>
const
  coFetchAll = TSQLConnectionOption(301);

procedure TForm1.SQLQuery1BeforeOpen(DataSet: TDataSet);
begin
  SQLConnection1.SQLConnection.SetOption(coFetchAll, Integer(False));
end;
</pre>

 <p>
If you compile the application for CLR, you should use
</p>

<pre>
  ISQLConnection_SetOption(SQLConnection1, ...)
</pre>

 <p>
instead of
</p>

<pre>
  SQLConnection1.SQLConnection.SetOption(...)
</pre>

<p>
Here is the description of the options and how to use them.
</p>
<br>

<p><i><b>
BCDPrecision
</b></i></p>

<p>
This string option allows dataset to represent fields as
TBCDField if NUMERIC field precision and scale less or equal than precision and
scale specified in BCDPrecision. String value is interpreted like two comma 
separated digits (BCD precision and scale). The default value of this option 
is blank (do not use TBCDField). The value of BCDPrecision cannot be greater 
then '14,4'.
</p>

<pre>
const
  coBCDPrecision = TSQLConnectionOption(208); // string
. . .
  SQLConnection1.SQLConnection.SetOption(coBCDPrecision, Integer(PChar('14,4')));
</pre>

<p><b><i>ApplicationName</b></i></p>
<p>
The name will be displayed in the pg_stat_activity view and included in CSV log entries. Only printable ASCII characters may be used in the application_name value. 
</p>
<p>
Note: This option is available for PostgreSQL 9.0 and higher.
</p> 
<p>
This option is available for Delphi 2007 and higher IDE versions.
</p>
<br>

<p><b><i>Charset</b></i></p>

<p>Sets character set that driver uses to read and write character data.</p>
<pre>
const
  coCharset = TSQLConnectionOption(204); //string
. . .
  SQLConnection1.SQLConnection.SetOption(coCharset, Integer(PChar('ASCII')));</pre>

<p><b><i>DetectParamTypes</b></i></p>
<p>If True, the driver ignores DataType property of parameters, and queries parameter types from the server. The default value of this option is False.</p>
<pre>
const
  coDetectParamTypes = TSQLConnectionOption(510); // boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coDetectParamTypes, Integer(True));</pre>


<p><i><b>
CursorWithHold
</b></i></p>

<p>
This option is used only if FetchAll option is set to False.
If CursorWithHold = False (default), an active transaction is required to open a query in FetchAll=False mode. If there is no active transaction, the driver opens additional internal connection and starts transaction on this connection.
If True, the driver uses DECLARE CURSOR ... WITH HOLD statement to open the query. In this case no active transaction is required but this may take additional server resources.
</p>

<pre>
const
  coCursorWithHold = TSQLConnectionOption(511); // boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coCursorWithHold, Integer(True));
</pre>


<p><i><b>
DBMonitorHost
</b></i></p>

<p>
Set this option to the host name where dbMonitor runs to enable remote monitoring.
</p>

<pre>
const
  coDBMonitorHost = TSQLConnectionOption(106); //string
. . .
  SQLConnection1.SQLConnection.SetOption(coDBMonitorHost, Integer(PChar('MyHost')));
</pre>


<p><i><b>
DBMonitorPort
</b></i></p>

<p>
Set this option to the port number of dbMonitor.
</p>

<pre>
const
  coDBMonitorPort = TSQLConnectionOption(107); //integer
. . .
  SQLConnection1.SQLConnection.SetOption(coDBMonitorPort, 1001);
</pre>


<p><b><i>EnableBCD</b></i></p>
<p>This boolean option with the True value allows driver to map NUMERIC, DECIMAL, BIGINT datatypes on ftFMTBcd field type.</p>
<pre>
const
  coEnableBCD = TSQLConnectionOption(102); // boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coEnableBCD, Integer(False));</pre>

<p><b><i>ExtendedFieldsInfo</b></i></p>

<p>If True, the driver performs additional queries to the database when opening a dataset. These queries return information about which fields of the dataset are required or autoincrement. Set this option to True, if you need the Required property of fields be set automatically.</p>
<pre>
const
  coExtendedFieldsInfo = TSQLConnectionOption(502); //boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coExtendedFieldsInfo, Integer(True));</pre>

<p><b><i>FetchAll</b></i></p> 

<p>When FetchAll is set to True, all records of the query are fetched from database when the dataset is opening. When set to False, records are retrieved when a data-aware component or a program requests it. If a query can return a lot of records, set this property to False if initial response time is important.</p>

<p><b>Note:</b> You should start a transaction before opening a query when FetchAll=False.</p>
<pre>
const
  coFetchAll = TSQLConnectionOption(301); //boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coFetchAll, Integer(True));</pre>

<p><i><b>IPVersion</b></i></p>

<p>Use IPVersion to specify which IP protocol version to use when a user connects to the server.</p>
<p>The following values are supported for this property:</p>

IPv4 - default<br>
IPv6<br>
IPBoth - try to connect by IPv6, if it is unavailable, then try by IPv4<br>
<br>
<pre>
const
  coIPVersion = TSQLConnectionOption(109); // string
. . .
  SQLConnection1.SQLConnection.SetOption(coIPVersion, Integer(PChar('IPv4')));</pre>

<p>This option is available for Delphi 2007 and higher IDE versions.</p>
<br>

<p><b><i>LongStrings</b></i></p> 

<p>When this boolean option is set to True, this allows dataset to represent long strings (more than 255 symbols) as memos. Default value of this option is True. </p>
<pre>
const
  coLongStrings = TSQLConnectionOption(101); // boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coLongStrings, Integer(False));</pre>
  
<p><b><i>OIDAsLargeObject</b></i></p>

<p>If True, fields with OID data type are treated as fields with large objects IDs. The driver will map such field on TBlobField, and read data from the corresponding large object automatically. If OIDAsLargeObject is set to False (default), OID data type is mapped on TIntegerField.</p>
<pre>
const
  coOIDAsLargeObject = TSQLConnectionOption(501); //boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coOIDAsLargeObject, Integer(True));</pre>

<p><b>Note 1:</b> you should start a transaction before opening a query with large objects.</p>

<p><b>Note 2:</b> if you need to edit TBlobField that corresponds a large object, set DetectParamTypes option to True. When you update TBlobField, the driver creates new large object and writes its OID to the field. An old large object that was referenced by this field becomes an orphan large object (an object that exist but is not referenced by any rows, wasting disk space). So do not update such fields, or create a trigger that unlinks old large object on update.</p>
<p><b>For example:</b></b>
<pre>
CREATE TABLE lo_test(id integer, image oid);

CREATE OR REPLACE FUNCTION test_lo_clean() RETURNS trigger AS $$
declare
  lo_oid oid;
begin
  -- If it is an update action but the BLOB (lo) field was not changed, dont do anything
  if (TG_OP = ''UPDATE'') then
    if (old.image = new.image) or (old.image is null) then
      return new;
    end if;
  end if;
  select into lo_oid loid from pg_largeobject where lo_oid = oid(old.image);
  if found then
    perform lo_unlink(lo_oid);
  end if;
  return new;
end$$
LANGUAGE 'plpgsql';

CREATE TRIGGER lo_cleanup
  AFTER DELETE OR UPDATE ON lo_test
  FOR EACH ROW EXECUTE PROCEDURE test_lo_clean();</pre>

<p><b><i>Prepared</i></b></p>

<p>This boolean option allows all dataset to be prepared. If you execute a query or a stored procedure more than once, you can improve performance by setting Prepared to True before opening the dataset. Setting Prepared to True prepares the dataset at once, rather than waiting until the dataset is opened.</p>
<pre>
const
  coPrepared = TSQLConnectionOption(302); // boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coPrepared, Integer(True));</pre>

<p><b><i>ProtocolVersion</i></b></p>

<p>Used to define PostgreSQL protocol version. There are two versions:
<table class="desctable" cellspacing="0">
<tr>
<th width="20%">Value</th>
<th width="70%">Meaning</th>
</tr>

<tr>
<td>pv20</td>
<td>Protocol 2.0 version</td>
</tr>

<tr>
<td>pv30</td>
<td>Protocol 3.0 version</td>
</tr>
</table>

PostgreSQL 7.3 and lower support the protocol 2.0 version only. PostgreSQL 7.4 and later support both protocols (2.0 and 3.0 versions). Protocol 3.0 version adds error codes, more status information, faster startup, better support for binary data transmission, parameter values separated from SQL commands, prepared statements, etc. So protocol 3.0 version is used by default.</p>
<p>This option is available for Delphi 2007 and higher IDE versions.</p>
<br>

<p><i><b>
Reconnect
</b></i></p>

<p>
This boolean option controls if automatic reconnection should be performed if the connection is broken. Setting the Reconnect option to False disables automatic reconnection.
</p>
<p>
Default value of this option is True.
</p>

<pre>
const
  coReconnect = TSQLConnectionOption(105);
. . .
  SQLConnection1.SQLConnection.SetOption(coReconnect, Integer(False));
</pre>

<p><b><i>SchemaName</i></b></p>

<p>Set the SchemaName option to change the search path of the connection to the specified schema. The TSQLTable and TSQLStoredProc components will search a table or stored procedure correspondingly in the specified schema if its Schema property is empty.</p>
<p>If you do not set the SchemaName option, the driver considers that the default schema is 'public'.</p>
<pre>
const
  coSchemaName = TSQLConnectionOption(28); // string
. . .
  SQLConnection1.SQLConnection.SetOption(coSchemaName, Integer(PChar('test')));</pre>

<p><b><i>SkipTransError</i></b></p>

<p>If True, the driver sets a savepoint before executing any SQL statement if a transaction is active. If an error occurs on executing of the SQL statement, the driver rolls back the transaction to the savepoint. This allows you to execute other statements on the transaction after an error.</p>
<p>Default value of this option is False.</p>
<pre>
const
  coSkipTransError = TSQLConnectionOption(512); // boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coSkipTransError, Integer(True));</pre>

<p><b><i>SSLMode</i></b></p>

<p>This option determines whether or with what priority an SSL connection will
be negotiated with the server. There are four modes:</p>

<table class="desctable" cellspacing="0">
<tr>
<th width="20%">Value</th>
<th width="70%">Meaning</th>
</tr>

<tr>
<td>DISABLE</td>
<td>Only an unencrypted SSL connection will be attempted. </td>
</tr>

<tr>
<td>ALLOW</td>
<td>Negotiates trying first a non-SSL connection, then if that fails, tries an SSL connection. </td>
</tr>

<tr>
<td>PREFER</td>
<td>Negotiates trying first an SSL connection, then if that fails, tries a regular non-SSL connection.</td>
</tr>

<tr>
<td>REQUIRE</td>
<td>Tries only an SSL connection. </td>
</tr>
</table>

<p>If PostgreSQL is compiled without SSL support, using option REQUIRE will cause an error, while options ALLOW and PREFER will be accepted but PgDAC will not in fact attempt an SSL connection.</p>
<p>It is available for Delphi 2007 and higher IDE versions.</p>
<pre>
SQLConnection1.Params.Values['SSLMode'] := 'REQUIRE';</pre>

<p><b><i>SSLCACert</i></b></p>
<p>CACert is the pathname to the certificate authority file. This option is available for Delphi 2007 and higher IDE versions.</p>
<pre>
SQLConnection1.Params.Values['SSLCACert'] := 'd:\Documents and Settings\User\Application Data\postgresql\root.crt';</pre>

<p><b><i>SSLCert</i></b></p>
<p>Cert is the pathname to the certificate file. This option is available for Delphi 2007 and higher IDE versions.</p>
<pre>
SQLConnection1.Params.Values['SSLCert'] := 'd:\Documents and Settings\User\Application Data\postgresql\postgresql.crt';</pre>

<p><b><i>SSLKey</i></b></p>
<p>Key is the pathname to the key file. This option is available for Delphi 2007 and higher IDE versions.</p>
<pre>
SQLConnection1.Params.Values['SSLKey'] := 'd:\Documents and Settings\User\Application Data\postgresql\postgresql.key';</pre>

<p><b><i>SSLCipherList</i></b></p>
<p>CipherList is the list of allowed ciphers to use for SSL encryption. This option is available for Delphi 2007 and higher IDE versions.</p>
<pre>
SQLConnection1.Params.Values['SSLCipherList'] := 'DES';</pre>

<p><b><i>TrimFixedChar</i></b></p> 

<p>Specifies whether to discard all trailing spaces in string fields of the dataset.</p> 
<pre>
const
  coTrimFixedChar = TSQLConnectionOption(103); // boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coTrimFixedChar, Integer(True));</pre>

<p><b><i>UnknownAsString</i></b></p>

<p>If False, fields of unknown data types (including geometric, composite and array types) are mapped to TMemoField or TWideMemoField depending on the value of the UseUnicode option. Memo is used because maximum length of values from such fields is unknown.</p>
<p>If True, fields of unknown data types are mapped to TStringField or TWideStringField depending on the value of the UseUnicode option. Size of fields is set to 8192. Values larger than this size are truncated.</p>
<p>The default value of this option is False.</p>
<pre>
const
  coUnknownAsString = TSQLConnectionOption(503); //boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coUnknownAsString, Integer(True));</pre>


<p><b><i>UnpreparedExecute</i></b></p>

<p>If the UnpreparedExecute option is set to True, the simple execute is used for SQL statement. Statement is not prepared before execute. It allows to add multiple statements separated by semicolon to the SQL property.</p>
<p>The default value of this option is False.</p>
<pre>
const
  coUnpreparedExecute = TSQLConnectionOption(509); //boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coUnpreparedExecute, Integer(True));</pre>


<p><i><b>
UseQuoteChar 
</b></i></p>

<p>
This boolean option when turned on makes the driver quote all names of objects. 
Setting it to True makes sense only for using reserved words as object names. 

Default value is False; 
</p>

<pre>
const
  coUseQuoteChar = TSQLConnectionOption(202); // boolean
. . .
  with SQLConnection1.SQLConnection do begin
    SetOption(coUseQuoteChar, Integer(True));
  end;
</pre>

In Delphi versions till 2007 this option can be set to TCRSQLConnection only

<p><i><b>
UseUnicode 
</b></i></p>
 
<p>
Enables or disables Unicode support. Affects character data 
fetched from the server. When set to True all character data is 
stored as WideStrings and TStringField is replaced with TWideStringFiled. 
</p>
 
<p>
This option is available for Delphi 2006 and higher IDE versions.
</p>
 
<p>
Default value of this option is True for Delphi 2009 and higher IDE versions,
and False for Delphi 2006 and 2007.
</p>
 
<pre>
const
  coUseUnicode = TSQLConnectionOption(209); // boolean
. . .
  SQLConnection1.SQLConnection.SetOption(coUseUnicode, Integer(True));
</pre>

<h4><a name="tcrsqlconnection"></a>TCRSQLConnection</h4>
<p>
TCRSQLConnection component serves to support additional options of
dbExpress drivers for InterBase (DbxIda), Oracle (DbxOda), 
SQL Server (DbxSda), MySQL (DbxMda), and PostgreSQL. Option configuration 
can be made in dbExpress configuration files (dbxconnections.ini) or 
in the Params list of TCRSQLConnection.
</p>

<p>
For example
</p>

<pre>
var
  SQLConnection1: TCRSQLConnection;
...
  SQLConnection1.Params.Values['UseUnicode'] := 'True';
  SQLConnection1.Connected := True;
</pre>

<p>
<b>Note:</b> for quick replacement of TSQLConnection to TCRSQLConnection 
at design-time it's enough to use context menu of the component.
</p>
<h4><a name="dbmon"></a>Using DBMonitor</h4>

<p>
To extend monitoring capabilities of dbExpress applications with the dbExpress for PostgreSQL
driver, you can use an additional freeware tool called <a href="http://www.devart.com/dbmonitor/index.html">DBMonitor</a>.
It is provided as an addition to a monitoring procedure with using
SQLMonitor component.
</p>

<p>
DBMonitor is easy-to-use tool to provide visual monitoring of your
database applications.
</p>

<p>
DBMonitor has the following features:
</p>

<ul>
  <li>Multiple client processes tracing;</li>
  <li>SQL event filtering (by sender objects);</li>
  <li>SQL parameter and error tracing.</li>
</ul>

<p>
DBMonitor is intended to hamper application being monitored as less as
possible.
</p>

<p>
To trace your application with DBMonitor you should follow these steps:
</p>

<ul>
  <li>drop TSQLMonitor component onto the form;</li>
  <li>start DBMonitor before running your program.</li>
</ul>

<p>
<b>Note:</b> if you are user of Delphi Pro version, you do not have the TSQLMonitor
component installed on the component palette. It is included in the SQLExpr.pas unit 
and you need to install it on the component palette manually.
</p>


<h4><a name="deployment"></a>Deployment</h4>

<p>
The following additional files are required on the target computer:
<table class="desctable" cellspacing="0">
  <tr>
    <th width="45%">File</th>
    <th width="35%">When required</th>
    <th width="20%">Where to find</th>
  </tr>
  <tr>
    <td>
      dbexppgsql.dll (dbexppgsql30.dll for Delphi 2006 or Turbo products users, 
      dbexppgsql40.dll for CodeGear RAD Studio 2007 and higher users)
    </td>
    <td>
      Required for any application
    </td>
    <td>
      dbExpress for PostgreSQL installation directory
    </td>
  </tr>
  <tr>
    <td>
      dbxintf.dll
    </td>
    <td>
      Required for any CLR application
    </td>
    <td>
      IDE installation directory
    </td>
  </tr>
  <tr>
    <td>
      Devart.DbxPgSql.DriverLoader.dll (should be placed in GAC)
    </td>
    <td>
      Required for CLR applications built with CodeGear RAD Studio 2007
    </td>
    <td>
      dbExpress for PostgreSQL installation directory
    </td>
  </tr>
</table>
</p>
 
<p>
Users of dbExpress driver for PostgreSQL with Source Code can embed the driver
into the application directly. For information on how to do this refer to Borland
documentation.
</p>

<h4><a name="trial_limitations"></a>Trial limitations</h4>

<p>
Windows dbExpress for PostgreSQL trial version can be used within 30 days starting from the moment of installation.
</p>

<h4><a name="notes"></a>Notes</h4>

<p>
Database object names that contain spaces or national language
characters should be always quoted. For example,
</p>

<pre>
  SQLStoredProc.StoredProcName := '&quot;My stored proc&quot;';
</pre>

<h4><a name="known_problems"></a>Known Problems</h4>

<ul>

<li><p>
When executing stored procedure using TSQLStoredProc component or TSQLDataSet with CommandType property set to ctStoredProc under Delphi 2006 CLR, dbExpress passes invalid length of BLOB parameters to the driver. That is why values of the BLOB parameters are truncated. To avoid this problem execute your stored  procedure as a query (set ctQuery for CommandType property of TSQLDataset or use TSQLQuery).
</li>
</p>

</ul>

<h4><a name="demo_projects"></a>Demo projects</h4>

<p>
The following demo projects accompany Devart dbExpress driver and provide a good bootstrap to
start working with it. They are located inside Dbx\PostgreSQL\Demos folder.
</p>

<table class="desctable" cellspacing="0">

<tr>
<th>Sample</th>
<th>Description</th>
</tr>

<tr>
<td><b>BlobPictures</b></td>
<td>
This sample project demonstrates how to work with binary BLOB type to store
images and display them in TDBImage
</td>
</tr>

<tr>
<td><b>ClientDataSet</b></td>
<td>
This sample project demonstrates working with TSQLClientDataSet in Delphi 6
</td>
</tr>

<tr>
<td><b>Query</b></td>
<td>
This sample project allows getting result record set using TSQLQuery component
</td>
</tr>

<tr>
<td><b>SimpleDataSet</b></td>
<td>
This sample project demonstrates working with TSimpleDataSet in Delphi 7
</td>
</tr>

<tr>
<td><b>StoredProc</b></td>
<td>
This sample project demonstrates working with input/output parameters and 
executing of stored procedures
</td>
</tr>

</table>

<!-- end content -->


<p>&nbsp;</p><p>&nbsp;</p><hr size=1> 
<p>&copy; 2001-2015 Devart. All rights reserved.</p>

</div>

<script>
TestEngine();
AdjustContentSize();
</script>
</body>
</html>
