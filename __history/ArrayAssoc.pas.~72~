unit ArrayAssoc;

{$WARNINGS OFF}
{$HINTS OFF}

interface

uses
  System.Classes,
  System.SysUtils,
  System.Generics.Collections,
  System.RTLConsts,
  System.Variants,
  System.RegularExpressions,
  Data.DB;

{ TODO 3 -oNickson Jeanmerson -cProgrammer :
1) Padronizar a Classes TArray e TArrayVariant; //OK
2) Padronizar a Classe TArrayField;
3) Criar Métodos Ausentes; }

{$REGION TConvert'}
type
  TConvert = record
  private
    { Private declarations }
    function ExtractStringBetweenDelims(Input: String; Delim1, Delim2: String): String;
    function VarToStr(Value : Variant) : String;
    function isNumeric(const Input: String) : Boolean;
    function isDecimal(const Input: String) : Boolean;
  public
    { Public declarations }
  end;
{$ENDREGION}

{$REGION 'TArray'}
type
  TArray = class(TStringList)
  private
    { Private declarations }
    function GetKey(Index: Integer): String;
    function GetValues(Index: string): string;
    function GetValuesAtIndex(Index: Integer): string;
    procedure SetValues(Index: string; const Value: string);
  public
    { Public declarations }
    constructor Create;
    destructor Destroy; override;
    function ToFilter: string;
    function ToString: string;
    procedure AddKeyValue(Key, Value: string);
    procedure Add(Key, Value: string); overload;
    property Key[Index : Integer] : String read GetKey;
    property ValuesAtIndex[Index: Integer]: string read GetValuesAtIndex;
    property Values[Index: string]: string read GetValues write SetValues; default;
  end;
{$ENDREGION}

{$REGION 'TArrayVariant'}
type
  TArrayVariant = class(TDictionary<String, Variant>)
  private
    { Private declarations }
    function GetKey(Index: Integer): String;
    function GetValues(Name: string): Variant;
    function GetValuesAtIndex(Index: Integer): Variant;
    procedure SetValues(Name: String; const Value: Variant);
  public
    { Public declarations }
    destructor Destroy; override;
    function ToFilter: string;
    function ToString: string;
    procedure AddKeyValue(Key : String; Value : Variant);
    procedure Add(Key : String; Value : Variant);
    property Key[Index : Integer] : String read GetKey;
    property ValuesAtIndex[Index: Integer]: Variant read GetValuesAtIndex;
    property Values[Name: string]: Variant read GetValues write SetValues;
  end;
{$ENDREGION}

{$REGION 'TArrayField'}
type
  TArrayField = class(TDictionary<String, TField>)
  private
    { Private declarations }
    function GetKey(Index: Integer): String;
    function GetValues(Name: string): TField;
    function GetValuesAtIndex(Index: Integer): TField;
    procedure SetValues(Name: String; const Value: TField);
  public
    { Public declarations }
    destructor Destroy; override;
    procedure AddKeyValue(Key : String; Value : TField);
    property Key[Index : Integer] : String read GetKey;
    property ValuesAtIndex[Index: Integer]: TField read GetValuesAtIndex;
    property Values[Name: string]: TField read GetValues write SetValues;
  end;
{$ENDREGION}

var
  Convert: TConvert;

implementation

{$REGION 'TConvert'}
function TConvert.ExtractStringBetweenDelims(Input: String; Delim1, Delim2: String): String;
var
  Pattern: String;
  RegEx: TRegEx;
  Match: TMatch;
begin
  Result := '';
  Pattern := Format('%s(.*?)%s', [Delim1, Delim2]);
  RegEx := TRegEx.Create(Pattern);
  Match := RegEx.Match(Input);
  if Match.Success and (Match.Groups.Count > 1) then
    Result := Match.Groups[1].Value;
end;

function TConvert.isNumeric(const Input: String) : Boolean;
begin
  Result := TRegEx.IsMatch(Input, '^\-?\d{1,}$');
end;

function TConvert.isDecimal(const Input: String) : Boolean;
begin
  Result := TRegEx.IsMatch(Input, '^\s*[-+]?[0-9]*\.?[0-9]+\s*$');
end;

function TConvert.VarToStr(Value: Variant): String;
begin
  case TVarData(Value).VType of
    varWord,
    varShortInt,
    varSmallInt,
    varInteger :
      Result := IntToStr(Value);
    varInt64 :
      Result := UIntToStr(Value);
    varSingle,
    varDouble,
    varCurrency :
      Result := FloatToStr(Value);
    varDate :
      Result := QuotedStr(FormatDateTime('yyyy-mm-dd', Value));
    varBoolean :
      if Value then
        Result := 'True'
      else
        Result := 'False';
    varString,
    varUString :
      if Self.isNumeric(Value) or Self.isDecimal(Value) then
        Result := Value
      else
        Result := QuotedStr(Value);
    else
      Result := QuotedStr(Value);
  end;
end;
{$ENDREGION}

{$REGION 'TArray'}
constructor TArray.Create;
begin
  NameValueSeparator := '|';
end;

destructor TArray.Destroy;
begin
  inherited;
end;

function TArray.ToFilter: string;
var
  I: Integer;
begin
  Result := '';
  for I := 0 to Count - 1 do
  begin
    Result := Result + Names[I] + ' ' + QuotedStr(ValuesAtIndex[I]) + ' ';
  end;
end;

function TArray.ToString: string;
var
  I: Integer;
begin
  Result := '';
  for I := 0 to Count - 1 do
  begin
    Result := Result + QuotedStr(ValuesAtIndex[I]);
  end;
end;

procedure TArray.Add(Key, Value: string);
begin
  Add(Key + NameValueSeparator + Value);
end;

procedure TArray.AddKeyValue(Key, Value: string);
begin
  Add(Key + NameValueSeparator + Value);
end;

function TArray.GetKey(Index: Integer): String;
begin
  inherited;
end;

function TArray.GetValues(Index: string): string;
begin
  Result := inherited Values[Index];
end;

function TArray.GetValuesAtIndex(Index: Integer): string;
begin
  Result := inherited Values[Names[Index]];
end;

procedure TArray.SetValues(Index: string; const Value: string);
begin
  inherited Values[Index] := Value;
end;
{$ENDREGION}

{$REGION 'TArrayVariant'}
destructor TArrayVariant.Destroy;
begin
  inherited;
end;

function TArrayVariant.ToFilter: string;
var
  I: Integer;
begin
  Result := '';
  for I := 0 to Count - 1 do
  begin
    Result := Result + Key[I] + ' ' + Convert.VarToStr(ValuesAtIndex[I]) + ' ';
  end;
end;

function TArrayVariant.ToString: string;
var
  I: Integer;
begin
  Result := '';
  for I := 0 to Count - 1 do
  begin
    Result := Result + Convert.VarToStr(ValuesAtIndex[I]);
  end;
end;

procedure TArrayVariant.Add(Key : String; Value : Variant);
begin
  inherited Add(Key, Value);
end;

procedure TArrayVariant.AddKeyValue(Key : String; Value : Variant);
begin
  AddOrSetValue(Key, Value);
end;

function TArrayVariant.GetKey(Index: Integer): String;
begin
  Result := ToArray[Index].Key;
end;

function TArrayVariant.GetValues(Name: string): Variant;
var
  OutValue : Variant;
begin
  TryGetValue(Name, OutValue);
  Result := OutValue;
end;

procedure TArrayVariant.SetValues(Name: String; const Value: Variant);
begin
  Values[Name] := Value;
  //Forma Legada
  //AddOrSetValue(Name, Variant(Value));
end;

function TArrayVariant.GetValuesAtIndex(Index: Integer): Variant;
var
  OutValue : Variant;
begin
  TryGetValue(Self.ToArray[Index].Key, OutValue);
  Result := OutValue;
end;
{$ENDREGION}

{$REGION 'TArrayField'}
destructor TArrayField.Destroy;
begin
  inherited;
end;

procedure TArrayField.AddKeyValue(Key: String; Value: TField);
begin
  AddKeyValue(Key, Value);
end;

function TArrayField.GetKey(Index: Integer): String;
begin
  Result := ToArray[Index].Key;
end;

function TArrayField.GetValues(Name: string): TField;
begin
  Result := Values[Name];
end;

function TArrayField.GetValuesAtIndex(Index: Integer): TField;
var
  OutValue : TField;
begin
  TryGetValue(Self.ToArray[Index].Key, OutValue);
  Result := OutValue;
end;

procedure TArrayField.SetValues(Name: String; const Value: TField);
begin
  Values[Name] := Value;
end;
{$ENDREGION}

{$WARNINGS ON}
{$HINTS ON}

end.
