{
  FormatType.Money.
  ------------------------------------------------------------------------------
  Objetivo : Simplificar a convesão, formatação e comparação de valores
  monetários e quantitativos em Delphi.
  Suporta 2 Modos de Resultado: ResultMode = (Truncate, Round);
  Suporta 2 Formatos de Resultado: ResultFormat = (BR, DB);
  OBS.:
  1 - O Formato DB é o Mesmo Utilizado em Campos Decimais, Double ou Float,
  de Bancos de Dados como MySQL/MariaDB, PostgreSQL, SQLite e etc...
  2 - Como Recomendação ao Definir seus Campos Monetários no Banco de Dados,
  Utilize um comprimento de grandeza igual ou superior à 18, ex: Decimal(18,x).
  3 - Não Serão Adicionados Símbolos Monetários como: R$, US$, etc...
  ------------------------------------------------------------------------------
  Autor : Nickson Jeanmerson
  Co-Autor : Wellington Fonseca
  ------------------------------------------------------------------------------
  Esta biblioteca é software livre; você pode redistribuí-la e/ou modificá-la
  sob os termos da Licença Pública Geral Menor do GNU conforme publicada pela
  Free Software Foundation; tanto a versão 3.29 da Licença, ou (a seu critério)
  qualquer versão posterior.
  Esta biblioteca é distribuída na expectativa de que seja útil, porém, SEM
  NENHUMA GARANTIA; nem mesmo a garantia implícita de COMERCIABILIDADE OU
  ADEQUAÇÃO A UMA FINALIDADE ESPECÍFICA. Consulte a Licença Pública Geral Menor
  do GNU para mais detalhes. (Arquivo LICENÇA.TXT ou LICENSE.TXT)
  Você deve ter recebido uma cópia da Licença Pública Geral Menor do GNU junto
  com esta biblioteca; se não, escreva para a Free Software Foundation, Inc.,
  no endereço 59 Temple Street, Suite 330, Boston, MA 02111-1307 USA.
  Você também pode obter uma copia da licença em:
  http://www.opensource.org/licenses/lgpl-license.php

  https://github.com/JackTrapper/Exact-Float-to-String-Routines
  https://stackoverflow.com/questions/4884263/delphi-isnumber
  https://stackoverflow.com/questions/21981399/fractional-part-to-int
  https://stackoverflow.com/questions/36675058/delphi-roundto-always-down
  https://stackoverflow.com/questions/50975653/convert-extended-80-bit-to-string
  https://stackoverflow.com/questions/22063157/why-does-floattotext-return-different-values-in-different-projects
  https://stackoverflow.com/questions/38817372/is-there-a-strtocurr-like-function-that-can-deal-with-thousand-separators
}

unit FormatType.Money;

interface

uses
  System.SysUtils,
  System.StrUtils,
  System.Math,
  System.RegularExpressions,

  System.MaskUtils,
  System.Character,

  FMX.Objects,
  FMX.Dialogs,
  FMX.Edit,

  Winapi.Windows,
  Winapi.Messages,
  Fetch.Locale,
  FormatType.Strings
  ;

type
  TLocaleMoney = class(TFetchLocale)
  private
    { Private declarations }
    class var _LOCALE_STHOUSAND, _LOCALE_SDECIMAL: String;
    class procedure StoreWindowsLocale();
    class procedure RestoreWindowsLocale();
    class procedure SetWindowsLocale(const &ThousandSeparator: String = '.'; const &DecimalSeparator: String = ',');
  public
    { Public declarations }
  end;

type
  TResultFormat = (BR, DB);
  TResultMode = (Truncate, Round);
  TFormatMoney = class
  private
    { Private declarations }
    {$HINTS OFF}
    class function StrToCurr(const Value: String): Currency; overload;
    class function StrToCurr(Value: String; const FormatSettings : TFormatSettings): Currency; overload;
    class function StrToFloat(const Value: String): Extended; overload;
    class function StrToFloat(Value: String; const FormatSettings : TFormatSettings): Extended; overload;
    class procedure GetFractionValue(Value: Extended; out Return : Integer); overload;
    class procedure GetFractionValue(Value: String; out QtdDecimal: Integer; out PosDecimal: Integer; out PosType : String); overload;
    class function FromFormat(Value: String; DecimalLength: Integer = 2; &DecimalSeparator : String = '.'): String; overload;
    class function FromFormat(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Variant; overload;
    class procedure ToFormat(out Return : String; Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.BR; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','); overload;
    class procedure ToFormat(out Return : Currency; Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','); overload;
    class procedure ToFormat(out Return : Double; Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','); overload;
    class procedure ToFormat(out Return : Extended; Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','); overload;
    {$HINTS ON}
  public
    { Public declarations }
    class function ToString(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.BR; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String; reintroduce;
    class function ToCurrency(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Currency;
    class function ToDouble(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Double;
    class function ToExtended(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Extended;
  end;

type
   TMoney = class helper for TFormatMoney
   public
    { Public declarations }
    function ToReal(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.BR; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String;
    function ToSQL(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String;
  end;

type TRoundToRange = -37..37;
function RoundTo(const AValue: Double; const ADigit: TRoundToRange): Double;
function SimpleRoundTo(const AValue: Double; const ADigit: TRoundToRange = -2): Double;
function SimpleRoundToEX(const AValue: Extended; const ADigit: TRoundToRange = -2): Extended;
function TruncFix(X: Extended): Int64;
function TruncTo(const AValue: Double; const Digits: TRoundToRange): Double;
function RoundABNT(const AValue: Double; const Digits: TRoundToRange; const Delta: Double = 0.00001 ): Double;

implementation

function RoundTo(const AValue: Double; const ADigit: TRoundToRange): Double;
var
  LFactor: Double;
begin
  LFactor := IntPower(10, ADigit);
  Result := System.Round(AValue / LFactor) * LFactor;
end;

function SimpleRoundTo(const AValue: Double; const ADigit: TRoundToRange = -2): Double;
var
  LFactor: Double;
begin
  LFactor := IntPower(10, ADigit);
  Result := Trunc((AValue / LFactor) + 0.5) * LFactor;
end;

function SimpleRoundToEX(const AValue: Extended; const ADigit: TRoundToRange = -2): Extended;
var
  LFactor: Extended;
begin
  LFactor := IntPower(10.0, ADigit);
  if AValue < 0 then
    Result := Int((AValue / LFactor) - 0.5) * LFactor
  else
    Result := Int((AValue / LFactor) + 0.5) * LFactor;
end;

function TruncFix( X : Extended ) : Int64 ;
begin
  Result := Trunc( SimpleRoundToEX( X, -9) ) ;
end;

function RoundABNT(const AValue: Double; const Digits: TRoundToRange; const Delta: Double = 0.00001 ): Double;
var
   Pow, FracValue, PowValue : Extended;
   RestPart: Double;
   IntCalc, FracCalc, LastNumber, IntValue : Int64;
   Negativo: Boolean;
Begin
   Negativo  := (AValue < 0);

   Pow       := IntPower(10, abs(Digits) );
   PowValue  := Abs(AValue) / 10 ;
   IntValue  := Trunc(PowValue);
   FracValue := Frac(PowValue);

   PowValue := SimpleRoundToEX( FracValue * 10 * Pow, -9);
   IntCalc  := Trunc( PowValue );
   FracCalc := Trunc( frac( PowValue ) * 100 );

   if (FracCalc > 50) then
     Inc( IntCalc )

   else if (FracCalc = 50) then
   begin
     LastNumber := System.Round( frac( IntCalc / 10) * 10);

     if Odd(LastNumber) then
       Inc( IntCalc )
     else
     begin
       RestPart := Frac( PowValue * 10 ) ;

       if RestPart > Delta then
         Inc( IntCalc );
     end ;
   end ;

   Result := ((IntValue*10) + (IntCalc / Pow));
   if Negativo then
     Result := -Result;
end;

function TruncTo(const AValue: Double; const Digits: TRoundToRange): Double;
var
 VFrac : Double;
 Pow: Extended;
begin
  Result := AValue;
  VFrac  := Frac(Result);

  if VFrac <> 0 then
  begin
    Pow    := intpower(10, abs(Digits) );
    VFrac  := TruncFix(VFrac * Pow);
    VFrac  := VFrac / Pow;
    Result := Int(Result) + VFrac  ;
  end;
end;

{ TLocaleMoney }

class procedure TLocaleMoney.RestoreWindowsLocale();
begin
  SetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, PWideChar(PWideString(WideString(_LOCALE_SDECIMAL))));
  SetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, PWideChar(PWideString(WideString(_LOCALE_STHOUSAND))));
end;

class procedure TLocaleMoney.StoreWindowsLocale();
begin
  _LOCALE_SDECIMAL := TFetchLocale.GetWindowsLocale(LOCALE_SDECIMAL);
  _LOCALE_STHOUSAND := TFetchLocale.GetWindowsLocale(LOCALE_STHOUSAND);
end;

class procedure TLocaleMoney.SetWindowsLocale(const &ThousandSeparator: String = '.'; const &DecimalSeparator: String = ',');
begin
  SetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, PWideChar(PWideString(WideString(&DecimalSeparator))));
  SetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, PWideChar(PWideString(WideString(&ThousandSeparator))));
  with FormatSettings do
  begin
    ThousandSeparator := &ThousandSeparator;
    DecimalSeparator := &DecimalSeparator;
  end;
end;

{ TFormatMoney }

class function TFormatMoney.StrToCurr(const Value: String): Currency;
var
  PosDecimal, QtdDecimal : Integer;
  PosType : String;
begin
  QtdDecimal := 0;
  PosDecimal := 0;
  PosType := EmptyStr;
  Self.GetFractionValue(Value, QtdDecimal, PosDecimal, PosType);
  // SplitString retorna AV, caso não haja nada após o separador
  if Length(SplitString(Value, PosType)) > 1 then
    Result := System.SysUtils.StrToCurr(TFormatStrings.OnlyNumeric(SplitString(Value, PosType)[0]) + FormatSettings.DecimalSeparator + SplitString(Value, PosType)[1])
  else
    Result := System.SysUtils.StrToCurr(Value);
end;

class function TFormatMoney.StrToCurr(Value: String; const FormatSettings: TFormatSettings): Currency;
begin
  Result:= Self.StrToCurr(Value, FormatSettings);
end;

class function TFormatMoney.StrToFloat(const Value: String): Extended;
var
  PosDecimal, QtdDecimal : Integer;
  PosType : String;
begin
  QtdDecimal := 0;
  PosDecimal := 0;
  PosType := EmptyStr;
  Self.GetFractionValue(Value, QtdDecimal, PosDecimal, PosType);
  // SplitString retorna AV, caso não haja nada após o separador
  if Length(SplitString(Value, PosType)) > 1 then
    Result := System.SysUtils.StrToFloat(TFormatStrings.OnlyNumeric(SplitString(Value, PosType)[0]) + FormatSettings.DecimalSeparator + SplitString(Value, PosType)[1])
  else
    Result := System.SysUtils.StrToFloat(Value);
end;

class function TFormatMoney.StrToFloat(Value: String; const FormatSettings: TFormatSettings): Extended;
begin
  Result:= Self.StrToFloat(Value, FormatSettings);
end;

class procedure TFormatMoney.GetFractionValue(Value: Extended; out Return: Integer);
var
  fFracValue : Extended;
  iFracLength : Integer;
begin
  Return := 0;
  fFracValue := Frac(Value);
  if fFracValue > 0 then
    fFracValue := SimpleRoundTo(fFracValue + 0.00000000001, -10)
  else if fFracValue < 0 then
    fFracValue := SimpleRoundTo(fFracValue - 0.00000000001, -10);
  if fFracValue = 0 then
    Exit;
  if fFracValue < 0 then
    iFracLength := Length(FloatToStr(fFracValue))-3
  else
    iFracLength := Length(FloatToStr(fFracValue))-2;
  if iFracLength <= 0 then
    Exit;
  Return := System.Round(fFracValue * Power(10, iFracLength));
end;

class procedure TFormatMoney.GetFractionValue(Value: String; out QtdDecimal: Integer; out PosDecimal: Integer; out PosType : String);
var
  RevString : String;
  PosComma, PosDot : Integer;
begin
  RevString := ReverseString(Value);
  PosComma := Pos(',', RevString);
  PosDot := Pos('.', RevString);

  if ( (PosComma <> 0) and (PosDot <> 0) ) then
  begin
    if (PosComma < PosDot) then
    begin
      QtdDecimal := PosComma-1;
      if QtdDecimal < 0 then
        QtdDecimal := 0;
      PosDecimal := PosComma;
    end
    else
    begin
      QtdDecimal := PosDot-1;
      if QtdDecimal < 0 then
        QtdDecimal := 0;
      PosDecimal := PosDot;
    end
  end
  else
  begin
    if PosComma > 0 then
    begin
      QtdDecimal := PosComma-1;
      if QtdDecimal < 0 then
        QtdDecimal := 0;
      PosDecimal := PosComma;
    end
    else
    begin
      QtdDecimal := PosDot-1;
      if QtdDecimal < 0 then
        QtdDecimal := 0;
      PosDecimal := PosDot;
    end
  end;
  if PosDecimal = PosDot then
    PosType := '.'
  else if PosDecimal = PosComma then
    PosType := ','
  else
    PosType := '';
end;

class function TFormatMoney.FromFormat(Value: String; DecimalLength: Integer; DecimalSeparator: String): String;
var
  Thousand, Decimal : String;
begin
  Value := TFormatStrings.OnlyNumeric(Value);
  Thousand := LeftStr(Value, Length(Value) - DecimalLength);
  Decimal := RightStr(Value, DecimalLength);
  Result := Thousand + DecimalSeparator + Decimal;
end;

class function TFormatMoney.FromFormat(Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Variant;
var
  ExtValue: Extended;
  Position, PosDecimal, QtdDecimal : Integer;
  ResDecimal, NumDecimal, PosType : String;
begin
  TLocaleMoney.StoreWindowsLocale();
  TLocaleMoney.SetWindowsLocale(&ThousandSeparator, &DecimalSeparator);
  try
    Value := TFormatStrings.OnlyValues(Value);
    Self.GetFractionValue(Value, QtdDecimal, PosDecimal, PosType);
    Value := TFormatStrings.OnlyNumeric(Value);
    Position := (Length(Value) - (PosDecimal)) + 2;

    ResDecimal := String('1').PadRight(QtdDecimal +1, '0');
    NumDecimal := StringOfChar('0', DecimalLength);

    if Mode = TResultMode.Round then
      ExtValue := RoundTo(System.SysUtils.StrToFloat(Value) / StrToInt(ResDecimal), -DecimalLength)
    else
      ExtValue := Self.StrToFloat(Copy(Value, 1, Position-1) + &DecimalSeparator + Copy(Value, Position, DecimalLength));

    if Format = TResultFormat.BR then
      Result := ReverseString(StringReplace(ReverseString(ExtValue.ToString), &ThousandSeparator, &DecimalSeparator, [rfReplaceAll]))
    else
      Result := ExtValue;
  finally
    TLocaleMoney.RestoreWindowsLocale();
  end;
end;

class procedure TFormatMoney.ToFormat(out Return: String; Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.BR; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ',');
var
  ExtValue: Extended;
begin
  ExtValue := Self.FromFormat(Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  if Format = TResultFormat.BR then
    Return := FormatFloat(',0.' + StringOfChar('0', DecimalLength), ExtValue)
  else
    Return := StringReplace(StringReplace(FloatToStr(ExtValue), '.', '', [rfReplaceAll]), ',', '.', [rfReplaceAll]);
end;

class procedure TFormatMoney.ToFormat(out Return: Currency; Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ',');
var
  CurrValue: Currency;
begin
  CurrValue := Self.FromFormat(Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Return := CurrValue;
end;

class procedure TFormatMoney.ToFormat(out Return: Double; Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ',');
var
  DoubValue: Double;
begin
  DoubValue := Self.FromFormat(Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Return := DoubValue;
end;

class procedure TFormatMoney.ToFormat(out Return: Extended; Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ',');
var
  ExtValue: Extended;
begin
  ExtValue := Self.FromFormat(Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Return := ExtValue;
end;

class function TFormatMoney.ToString(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.BR; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String;
var
  Return : String;
begin
  Return := Value;
  Self.ToFormat(Return, Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Result := Return;
end;

class function TFormatMoney.ToCurrency(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Currency;
var
  Return : Currency;
begin
  Return := Self.StrToCurr(TFormatStrings.OnlyValues(Value));
  Self.ToFormat(Return, Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Result := Return;
end;

class function TFormatMoney.ToDouble(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Double;
var
  Return : Double;
begin
  Return := Self.StrToFloat(TFormatStrings.OnlyValues(Value));
  Self.ToFormat(Return, Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Result := Return;
end;

class function TFormatMoney.ToExtended(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Extended;
var
  Return : Extended;
begin
  Return := Self.StrToFloat(TFormatStrings.OnlyValues(Value));
  Self.ToFormat(Return, Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Result := Return;
end;

end.

