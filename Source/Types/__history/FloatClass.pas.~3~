{
  FloatClass.
  ------------------------------------------------------------------------------
  Objetivo : Simplificar a convesão, formatação e comparação de valores
  monetários e quantitativos em Delphi.
  Suporta 2 Modos de Resultado: ResultMode = (Truncate, Round);
  Suporta 2 Formatos de Resultado: ResultFormat = (BR, DB);
  OBS.:
  1 - O Formato DB é o Mesmo Utilizado em Campos Decimais, Double ou Float,
  de Bancos de Dados como MySQL/MariaDB, PostgreSQL, SQLite e etc...
  2 - Como Recomendação ao Definir seus Campos Monetários no Banco de Dados,
  Utilize um comprimento de grandeza igual ou superior à 18, ex: Decimal(18,x).
  3 - Não Serão Adicionados Símbolos Monetários como: R$, US$, etc...
  ------------------------------------------------------------------------------
  Autor : Nickson Jeanmerson
  Co-Autor : Wellington Fonseca
  ------------------------------------------------------------------------------
  Esta biblioteca é software livre; você pode redistribuí-la e/ou modificá-la
  sob os termos da Licença Pública Geral Menor do GNU conforme publicada pela
  Free Software Foundation; tanto a versão 3.29 da Licença, ou (a seu critério)
  qualquer versão posterior.
  Esta biblioteca é distribuída na expectativa de que seja útil, porém, SEM
  NENHUMA GARANTIA; nem mesmo a garantia implícita de COMERCIABILIDADE OU
  ADEQUAÇÃO A UMA FINALIDADE ESPECÍFICA. Consulte a Licença Pública Geral Menor
  do GNU para mais detalhes. (Arquivo LICENÇA.TXT ou LICENSE.TXT)
  Você deve ter recebido uma cópia da Licença Pública Geral Menor do GNU junto
  com esta biblioteca; se não, escreva para a Free Software Foundation, Inc.,
  no endereço 59 Temple Street, Suite 330, Boston, MA 02111-1307 USA.
  Você também pode obter uma copia da licença em:
  http://www.opensource.org/licenses/lgpl-license.php

  https://github.com/JackTrapper/Exact-Float-to-String-Routines
  https://stackoverflow.com/questions/4884263/delphi-isnumber
  https://stackoverflow.com/questions/21981399/fractional-part-to-int
  https://stackoverflow.com/questions/36675058/delphi-roundto-always-down
  https://stackoverflow.com/questions/50975653/convert-extended-80-bit-to-string
  https://stackoverflow.com/questions/22063157/why-does-floattotext-return-different-values-in-different-projects
  https://stackoverflow.com/questions/38817372/is-there-a-strtocurr-like-function-that-can-deal-with-thousand-separators
}

unit FloatClass;

interface

uses
  System.SysUtils,
  System.StrUtils,
  System.Math,
  System.RegularExpressions,

  System.MaskUtils,
  System.Character,

  FMX.Objects,
  FMX.Dialogs,
  FMX.Edit,

  Winapi.Windows,
  Winapi.Messages,
  Locale,
  StringClass
  ;

type
  TLocaleFloat = class(TLocale)
  private
    { Private declarations }
    class var _LOCALE_STHOUSAND, _LOCALE_SDECIMAL: String;
    class procedure StoreWindowsLocale();
    class procedure RestoreWindowsLocale();
    class procedure SetWindowsLocale(const &ThousandSeparator: String = '.'; const &DecimalSeparator: String = ',');
  public
    { Public declarations }
  end;

type
  TRoundToRange = -37..37;
  TResultFormat = (BR, DB);
  TResultMode = (Truncate, Round);
  TFloat = class
  protected
    { Private declarations }
    class function RoundTo(const AValue: Double; const ADigit: TRoundToRange): Double;
    class function SimpleRoundTo(const AValue: Double; const ADigit: TRoundToRange = -2): Double;
    class function SimpleRoundToEX(const AValue: Extended; const ADigit: TRoundToRange = -2): Extended;
    class function TruncFix(X: Extended): Int64;
    class function TruncTo(const AValue: Double; const Digits: TRoundToRange): Double;
    class function RoundABNT(const AValue: Double; const Digits: TRoundToRange; const Delta: Double = 0.00001 ): Double;
  private
    { Private declarations }
    class function StrToCurr(const Value: String): Currency; overload;
    class function StrToCurr(Value: String; const FormatSettings : TFormatSettings): Currency; overload;
    class function StrToFloat(const Value: String): Extended; overload;
    class function StrToFloat(Value: String; const FormatSettings : TFormatSettings): Extended; overload;
    class procedure GetFractionValue(Value: Extended; out Return : Integer); overload;
    class procedure GetFractionValue(Value: String; out QtdDecimal: Integer; out PosDecimal: Integer; out PosType : String); overload;
    class function FromFormat(Value: String; DecimalLength: Integer = 2; &DecimalSeparator : String = '.'): String; overload;
    class function FromFormat(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Variant; overload;
    class procedure ToFormat(out Return : String; Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.BR; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','); overload;
    class procedure ToFormat(out Return : Currency; Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','); overload;
    class procedure ToFormat(out Return : Double; Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','); overload;
    class procedure ToFormat(out Return : Extended; Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','); overload;
  public
    { Public declarations }
    class function ToString(Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.BR; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String; reintroduce; overload;
    class function ToString(Value: String; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.BR; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String; overload;

    class function ToCurrency(Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Currency; overload;
    class function ToCurrency(Value: String; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Currency; overload;

    class function ToDouble(Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Double; overload;
    class function ToDouble(Value: String; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Double; overload;

    class function ToExtended(Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Extended; overload;
    class function ToExtended(Value: String; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Extended; overload;

    class function ToReal(Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String; overload;
    class function ToReal(Value: String; Mode: TResultMode = TResultMode.Round; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String; overload;

    class function ToSQL(Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String; overload;
    class function ToSQL(Value: String; Mode: TResultMode = TResultMode.Round; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String; overload;

    function QueryInterface(const IID: TGUID; out Obj): HRESULT; stdcall;
  end;

implementation

{ TLocaleFloat }

class procedure TLocaleFloat.RestoreWindowsLocale();
begin
  SetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, PWideChar(PWideString(WideString(_LOCALE_SDECIMAL))));
  SetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, PWideChar(PWideString(WideString(_LOCALE_STHOUSAND))));
end;

class procedure TLocaleFloat.StoreWindowsLocale();
begin
  _LOCALE_SDECIMAL := TLocale.GetWindowsLocale(LOCALE_SDECIMAL);
  _LOCALE_STHOUSAND := TLocale.GetWindowsLocale(LOCALE_STHOUSAND);
end;

class procedure TLocaleFloat.SetWindowsLocale(const &ThousandSeparator: String = '.'; const &DecimalSeparator: String = ',');
begin
  SetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, PWideChar(PWideString(WideString(&DecimalSeparator))));
  SetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, PWideChar(PWideString(WideString(&ThousandSeparator))));
  with FormatSettings do
  begin
    ThousandSeparator := &ThousandSeparator;
    DecimalSeparator := &DecimalSeparator;
  end;
end;

{ TFloat }

class function TFloat.RoundTo(const AValue: Double; const ADigit: TRoundToRange): Double;
var
  LFactor: Double;
begin
  LFactor := IntPower(10, ADigit);
  Result := System.Round(AValue / LFactor) * LFactor;
end;

class function TFloat.SimpleRoundTo(const AValue: Double; const ADigit: TRoundToRange = -2): Double;
var
  LFactor: Double;
begin
  LFactor := IntPower(10, ADigit);
  Result := Trunc((AValue / LFactor) + 0.5) * LFactor;
end;

class function TFloat.SimpleRoundToEX(const AValue: Extended; const ADigit: TRoundToRange = -2): Extended;
var
  LFactor: Extended;
begin
  LFactor := IntPower(10.0, ADigit);
  if AValue < 0 then
    Result := Int((AValue / LFactor) - 0.5) * LFactor
  else
    Result := Int((AValue / LFactor) + 0.5) * LFactor;
end;

class function TFloat.TruncFix( X : Extended ) : Int64 ;
begin
  Result := Trunc( SimpleRoundToEX( X, -9) ) ;
end;

class function TFloat.RoundABNT(const AValue: Double; const Digits: TRoundToRange; const Delta: Double = 0.00001 ): Double;
var
  Pow, FracValue, PowValue : Extended;
  RestPart: Double;
  IntCalc, FracCalc, LastNumber, IntValue : Int64;
  Negativo: Boolean;
Begin
  Negativo  := (AValue < 0);
  Pow       := IntPower(10, Abs(Digits) );
  PowValue  := Abs(AValue) / 10 ;
  IntValue  := Trunc(PowValue);
  FracValue := Frac(PowValue);
  PowValue := Self.SimpleRoundToEX( FracValue * 10 * Pow, -9);
  IntCalc  := Trunc( PowValue );
  FracCalc := Trunc( frac( PowValue ) * 100 );
  if (FracCalc > 50) then
    Inc( IntCalc )
  else if (FracCalc = 50) then
  begin
    LastNumber := System.Round( Frac( IntCalc / 10) * 10);
    if Odd(LastNumber) then
      Inc( IntCalc )
    else
    begin
      RestPart := Frac( PowValue * 10 ) ;
      if RestPart > Delta then
        Inc( IntCalc );
    end;
  end;
  Result := ((IntValue*10) + (IntCalc / Pow));
  if Negativo then
    Result := -Result;
end;

class function TFloat.TruncTo(const AValue: Double; const Digits: TRoundToRange): Double;
var
 VFrac : Double;
 Pow: Extended;
begin
  Result := AValue;
  VFrac  := Frac(Result);
  if VFrac <> 0 then
  begin
    Pow    := IntPower(10, Abs(Digits) );
    VFrac  := Self.TruncFix(VFrac * Pow);
    VFrac  := VFrac / Pow;
    Result := Int(Result) + VFrac  ;
  end;
end;

class function TFloat.StrToCurr(const Value: String): Currency;
var
  PosDecimal, QtdDecimal : Integer;
  PosType : String;
begin
  QtdDecimal := 0;
  PosDecimal := 0;
  PosType := EmptyStr;
  Self.GetFractionValue(Value, QtdDecimal, PosDecimal, PosType);
  if Length(SplitString(Value, PosType)) > 1 then
    Result := System.SysUtils.StrToCurr(TString.OnlyNumeric(SplitString(Value, PosType)[0]) + FormatSettings.DecimalSeparator + SplitString(Value, PosType)[1])
  else
    Result := System.SysUtils.StrToCurr(Value);
end;

class function TFloat.StrToCurr(Value: String; const FormatSettings: TFormatSettings): Currency;
begin
  Result:= Self.StrToCurr(Value, FormatSettings);
end;

class function TFloat.StrToFloat(const Value: String): Extended;
var
  PosDecimal, QtdDecimal : Integer;
  PosType : String;
begin
  QtdDecimal := 0;
  PosDecimal := 0;
  PosType := EmptyStr;
  Self.GetFractionValue(Value, QtdDecimal, PosDecimal, PosType);
  if Length(SplitString(Value, PosType)) > 1 then
    Result := System.SysUtils.StrToFloat(TString.OnlyNumeric(SplitString(Value, PosType)[0]) + FormatSettings.DecimalSeparator + SplitString(Value, PosType)[1])
  else
    Result := System.SysUtils.StrToFloat(Value);
end;

class function TFloat.StrToFloat(Value: String; const FormatSettings: TFormatSettings): Extended;
begin
  Result:= Self.StrToFloat(Value, FormatSettings);
end;

class procedure TFloat.GetFractionValue(Value: Extended; out Return: Integer);
var
  fFracValue : Extended;
  iFracLength : Integer;
begin
  Return := 0;
  fFracValue := Frac(Value);
  if fFracValue > 0 then
    fFracValue := SimpleRoundTo(fFracValue + 0.00000000001, -10)
  else if fFracValue < 0 then
    fFracValue := SimpleRoundTo(fFracValue - 0.00000000001, -10);
  if fFracValue = 0 then
    Exit;
  if fFracValue < 0 then
    iFracLength := Length(FloatToStr(fFracValue))-3
  else
    iFracLength := Length(FloatToStr(fFracValue))-2;
  if iFracLength <= 0 then
    Exit;
  Return := System.Round(fFracValue * Power(10, iFracLength));
end;

class procedure TFloat.GetFractionValue(Value: String; out QtdDecimal: Integer; out PosDecimal: Integer; out PosType : String);
var
  RevString : String;
  PosComma, PosDot : Integer;
begin
  RevString := ReverseString(Value);
  PosComma := Pos(',', RevString);
  PosDot := Pos('.', RevString);

  if ( (PosComma <> 0) and (PosDot <> 0) ) then
  begin
    if (PosComma < PosDot) then
    begin
      QtdDecimal := PosComma-1;
      if QtdDecimal < 0 then
        QtdDecimal := 0;
      PosDecimal := PosComma;
    end
    else
    begin
      QtdDecimal := PosDot-1;
      if QtdDecimal < 0 then
        QtdDecimal := 0;
      PosDecimal := PosDot;
    end
  end
  else
  begin
    if PosComma > 0 then
    begin
      QtdDecimal := PosComma-1;
      if QtdDecimal < 0 then
        QtdDecimal := 0;
      PosDecimal := PosComma;
    end
    else
    begin
      QtdDecimal := PosDot-1;
      if QtdDecimal < 0 then
        QtdDecimal := 0;
      PosDecimal := PosDot;
    end
  end;
  if PosDecimal = PosDot then
    PosType := '.'
  else if PosDecimal = PosComma then
    PosType := ','
  else
    PosType := '';
end;

class function TFloat.FromFormat(Value: String; DecimalLength: Integer; DecimalSeparator: String): String;
var
  Thousand, Decimal : String;
begin
  Value := TString.OnlyNumeric(Value);
  Thousand := LeftStr(Value, Length(Value) - DecimalLength);
  Decimal := RightStr(Value, DecimalLength);
  Result := Thousand + DecimalSeparator + Decimal;
end;

class function TFloat.FromFormat(Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Variant;
var
  ExtValue: Extended;
  Position, PosDecimal, QtdDecimal : Integer;
  ResDecimal, NumDecimal, PosType : String;
begin
  TLocaleFloat.StoreWindowsLocale();
  TLocaleFloat.SetWindowsLocale(&ThousandSeparator, &DecimalSeparator);
  try
    Value := TString.OnlyValues(Value);
    Self.GetFractionValue(Value, QtdDecimal, PosDecimal, PosType);
    Value := TString.OnlyNumeric(Value);
    Position := (Length(Value) - (PosDecimal)) + 2;

    ResDecimal := String('1').PadRight(QtdDecimal +1, '0');
    NumDecimal := StringOfChar('0', DecimalLength);

    if Mode = TResultMode.Round then
      ExtValue := RoundTo(System.SysUtils.StrToFloat(Value) / StrToInt(ResDecimal), -DecimalLength)
    else
      ExtValue := Self.StrToFloat(Copy(Value, 1, Position-1) + &DecimalSeparator + Copy(Value, Position, DecimalLength));

    if Format = TResultFormat.BR then
      Result := ReverseString(StringReplace(ReverseString(ExtValue.ToString), &ThousandSeparator, &DecimalSeparator, [rfReplaceAll]))
    else
      Result := ExtValue;
  finally
    TLocaleFloat.RestoreWindowsLocale();
  end;
end;

class procedure TFloat.ToFormat(out Return: String; Value: String; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.BR; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ',');
var
  ExtValue: Extended;
begin
  ExtValue := Self.FromFormat(Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  if Format = TResultFormat.BR then
    Return := FormatFloat(',0.' + StringOfChar('0', DecimalLength), ExtValue)
  else
    Return := TStringHelper.StringReplace(FloatToStr(ExtValue), ['.', ','], ['', '.'], [rfReplaceAll]);
end;

class procedure TFloat.ToFormat(out Return: Currency; Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ',');
var
  CurrValue: Currency;
begin
  CurrValue := Self.FromFormat(Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Return := CurrValue;
end;

class procedure TFloat.ToFormat(out Return: Double; Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ',');
var
  DoubValue: Double;
begin
  DoubValue := Self.FromFormat(Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Return := DoubValue;
end;

class procedure TFloat.ToFormat(out Return: Extended; Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ',');
var
  ExtValue: Extended;
begin
  ExtValue := Self.FromFormat(Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Return := ExtValue;
end;

class function TFloat.ToString(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.BR; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String;
var
  Return : String;
begin
  Return := Value;
  Self.ToFormat(Return, Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Result := Return;
end;

class function TFloat.ToCurrency(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Currency;
var
  Return : Currency;
begin
  Return := Self.StrToCurr(TString.OnlyValues(Value));
  Self.ToFormat(Return, Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Result := Return;
end;

class function TFloat.ToDouble(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Double;
var
  Return : Double;
begin
  Return := Self.StrToFloat(TString.OnlyValues(Value));
  Self.ToFormat(Return, Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Result := Return;
end;

class function TFloat.ToExtended(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): Extended;
var
  Return : Extended;
begin
  Return := Self.StrToFloat(TString.OnlyValues(Value));
  Self.ToFormat(Return, Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
  Result := Return;
end;

class function TFloat.ToReal(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.BR; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String;
begin
  //Result := Self.ToString(Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
end;

class function TFloat.ToSQL(Value: string; DecimalLength: Integer = 2; Mode: TResultMode = TResultMode.Round; Format: TResultFormat = TResultFormat.DB; const &ThousandSeparator: Char = '.'; const &DecimalSeparator: Char = ','): String;
begin
  //Result := Self.ToString(Value, DecimalLength, Mode, Format, &ThousandSeparator, &DecimalSeparator);
end;

end.

